---
title: LeetCode 刷题笔记
date: 2024-03-31 10:49:06 +0800
categories: [Algorithm, LeetCode]
tags: [leetcode]
author: kuromesi
math: true
---

## [2952. 需要添加的硬币的最小数量](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/description/?envType=daily-question&envId=2024-03-25)

### 题目

给你一个下标从 0 开始的整数数组 coins，表示可用的硬币的面值，以及一个整数 target 。

如果存在某个 coins 的子序列总和为 x，那么整数 x 就是一个 **可取得的金额** 。

返回需要添加到数组中的 **任意面值** 硬币的 最小数量 ，使范围 [1, target] 内的每个整数都属于 可取得的金额 。

数组的 **子序列** 是通过删除原始数组的一些（可能不删除）元素而形成的新的 **非空** 数组，删除过程不会改变剩余元素的相对位置。

### 解题思路

对于一个数 $x$，如果 $[1, x - 1]$ 可以取得，那么对于 $y \leq x$来说，一定有 $[1, y - 1]$ 可以取得，因此遍历到新的面额 $y$，一定有 $[1, x + y - 1]$ 可以取得。而如果 $y \gt x$ 时，加上新的面额无法保证 $[1, x + y - 1]$ 可以取得。因为 $[x, y - 1]$ 是无法取得的。

例如 $x = 4$，$y = 5$，此时存在的面额为 $[1, 2]$，如果添加面额 $4$，则新的取值范围变为 $[1, 7]$，但很明显 $4$ 是无法取到的。

因此此时只能在原有 $x$ 的基础上再加一个 $x$，此时新的可取的面额为 $[1, 2x - 1]$。而由于 $x$ 不存在与原有的硬币序列中，因此需要对 答案加一。

持续上述过程，直到覆盖 target。

### 题解

```java
class Solution {
    public int minimumAddedCoins(int[] coins, int target) {
        Arrays.sort(coins);
        int idx = 0, x = 1, ans = 0;
        while (x <= target) {
            if (idx < coins.length && coins[idx] <= x) {
                x += coins[idx];
                idx++;
            } else {
                x *= 2;
                ans++;
            }
        }
        return ans;
    }
}
```